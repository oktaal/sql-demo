import { useEffect, useState } from 'react'
import './App.css'
import { PGliteProvider } from '@electric-sql/pglite-react'
import { live, PGliteWithLive } from '@electric-sql/pglite/live'
import { PGlite } from '@electric-sql/pglite'
import NotebookComponent from './NotebookComponent'

let dbGlobal: PGliteWithLive | undefined

function App() {
  const [db, setDb] = useState<PGliteWithLive | undefined>();
  const [readonly, setReadonly] = useState<boolean>(true);

  useEffect(() => {
    async function setupDb() {
      // Initialising a PGlite instance in a useEffect hook is a good pattern.
      // However, it doesn't play well with React's strict mode, so we'll use a global
      // variable to store the instance once it's initialised. That way strict mode
      // doesn't re-initialise it.
      dbGlobal ??= await PGlite.create({
        extensions: { live },
      })
      setDb(dbGlobal)
    }
    setupDb()
  }, [])

  return (
    <>
      <div className="container">
        <h1 className='my-5'>SQL Demo {
          readonly
            ? <span className="btn btn-secondary" onClick={() => setReadonly(false)}>readonly</span>
            : <span className="btn btn-danger" onClick={() => setReadonly(true)}>editable</span>
        }</h1>
        {/* see details https://pglite.dev/docs/framework-hooks/react#pgliteprovider */}
        {db ? (
          <PGliteProvider db={db}>
            <NotebookComponent readonly={readonly} queries={[
              "CREATE TABLE questions (\n  id SERIAL PRIMARY KEY,\n  text TEXT)",
              "INSERT INTO questions\n  (text)\nVALUES\n  ('How did you go to work today?'),\n  ('by bike'),\n  ('by car'),\n  ('by public transport'),\n  ('working from home'),\n  ('Is the weather nice?'),\n  ('could be better'),\n  ('it''s great!'),\n  ('did not look outside yet'),\n  ('could be better') -- oops duplicate!",
              "SELECT * FROM questions;",
              "-- let's start with marking the questions\nSELECT id, text, CASE WHEN text LIKE '%?' THEN 1 ELSE 0 END as is_question\nFROM questions;",
              "-- but how do we group by a property which does not exist?\nSELECT text, CASE WHEN text LIKE '%?' THEN 1 ELSE 0 END AS is_question, COUNT(1)\nFROM questions\nGROUP BY (CASE WHEN text LIKE '%?' THEN 1 ELSE 0 END), text\nORDER BY text;",
              "-- but that was very repetitive, this could be done with a sub-query:\nSELECT text, is_question, COUNT(1)\nFROM (SELECT id, text, CASE WHEN text LIKE '%?' THEN 1 ELSE 0 END AS is_question\n  FROM questions)\nGROUP BY is_question, text\nORDER BY text;",
              "-- or with a common table expression:\nWITH marked_questions AS (\n  SELECT id, text, CASE WHEN text LIKE '%?' THEN 1 ELSE 0 END AS is_question\n  FROM questions)\nSELECT text, is_question, COUNT(1)\nFROM marked_questions\nGROUP BY is_question, text\nORDER BY text;",
              "-- this makes it possible to re-use the same virtual table multiple times:\nWITH marked_questions AS (\n  SELECT id, text, CASE WHEN text LIKE '%?' THEN 1 ELSE 0 END AS is_question\n  FROM questions),\nactual_questions AS (\n  SELECT id AS question_id,\n    -- get the next question_id using LEAD\n    LEAD(id, 1) OVER (ORDER BY id) AS next_question_id,\n    text AS question_text\n  FROM marked_questions\n  WHERE is_question = 1),\nanswers AS (\n  SELECT id AS answer_id, text AS answer_text\n  FROM marked_questions\n  WHERE is_question = 0)\nSELECT question_id,\n  next_question_id,\n  question_text,\n  answer_id,\n  answer_text\nFROM actual_questions\nJOIN answers\n  ON question_id < answer_id\n  -- knowing the next question_id we can figure out the associated answers:\n  AND (next_question_id IS NULL\n     OR answer_id < next_question_id)\nORDER BY answer_id;",
              "-- time to store the answers into a separate table\nCREATE TABLE answers(\n    id INT GENERATED BY DEFAULT AS IDENTITY,\n    question_id INT,\n    text TEXT,\n    CONSTRAINT fk_question\n        FOREIGN KEY (question_id)\n        REFERENCES questions(id)\n        ON DELETE CASCADE -- if we remove the question, remove the associated answers\n);\n",
              "BEGIN TRANSACTION; -- we want to check if it works first!\n",
              "-- copy paste the previous query, but now we use it to insert the actual data\nWITH marked_questions AS (\n  SELECT id, text, CASE WHEN text LIKE '%?' THEN 1 ELSE 0 END AS is_question\n  FROM questions),\nactual_questions AS (\n  SELECT id AS question_id,\n    -- get the next question_id using LEAD\n    LEAD(id, 1) OVER (ORDER BY id) AS next_question_id,\n    text AS question_text\n  FROM marked_questions\n  WHERE is_question = 1),\nanswers AS (\n  SELECT id AS answer_id, text AS answer_text\n  FROM marked_questions\n  WHERE is_question = 0)\nINSERT INTO answers\n(id, question_id, text)\nSELECT answer_id,\n  question_id,\n  answer_text\nFROM actual_questions\nJOIN answers\n  ON question_id < answer_id\n  -- knowing the next question_id we can figure out the associated answers:\n  AND (next_question_id IS NULL\n     OR answer_id < next_question_id)\nORDER BY answer_id;",
              "SELECT *\nFROM answers;",
              "-- wait, let's go back!\nROLLBACK TRANSACTION;",
              "SELECT *\nFROM answers;",
              "-- the same as the previous query\nWITH marked_questions AS (\n  SELECT id, text, CASE WHEN text LIKE '%?' THEN 1 ELSE 0 END AS is_question\n  FROM questions),\nactual_questions AS (\n  SELECT id AS question_id,\n    -- get the next question_id using LEAD\n    LEAD(id, 1) OVER (ORDER BY id) AS next_question_id,\n    text AS question_text\n  FROM marked_questions\n  WHERE is_question = 1),\nanswers AS (\n  SELECT id AS answer_id, text AS answer_text\n  FROM marked_questions\n  WHERE is_question = 0),\nduplicated_answers AS (\n  SELECT answer_id,\n    question_id,\n    answer_text\n  FROM actual_questions\n  JOIN answers\n    ON question_id < answer_id\n    -- knowing the next question_id we can figure out the associated answers:\n    AND (next_question_id IS NULL\n       OR answer_id < next_question_id)),\n-- this gets rid of the duplicate:\nunique_answers AS (\n  SELECT MIN(answer_id) AS answer_id, question_id, answer_text\n  FROM duplicated_answers\n  GROUP BY question_id, answer_text)\nINSERT INTO answers (id, question_id, text)\nSELECT answer_id, question_id, answer_text\nFROM unique_answers;",
              "-- we still have a bunch of weird questions left\nSELECT q.id AS question_id, q.text AS question_text, a.id AS answer_id, a.text AS answer_text\nFROM questions q\nLEFT JOIN answers a\n  ON q.id = a.question_id",
              "-- delete those questions\nDELETE\nFROM questions q\nWHERE NOT EXISTS (SELECT 1 FROM answers WHERE question_id = q.id)",
              "-- should be only two questions left\nSELECT * FROM questions;",
              "-- now let's look at our final results\nSELECT q.id AS question_id, q.text AS question_text, a.id AS answer_id, a.text AS answer_text\nFROM questions q, answers a\nWHERE q.id = a.question_id\nORDER BY a.id",
              "-- This small demo works completely in-browser using https://github.com/electric-sql/pglite\n-- It's here: https://github.com/oktaal/sql-demo",
            ]} />
          </PGliteProvider>
        ) : (
          <div>Loading PGlite...</div>
        )}
      </div>
    </>
  )
}

export default App
